From 1ed118c1aa5a82a790bed8a585ff13462899b0f0 Mon Sep 17 00:00:00 2001
From: wanghaijun <whjwnavy@163.com>
Date: Thu, 23 Dec 2021 16:12:29 +0800
Subject: [PATCH 2/2] code lint

---
 extern/ch_cgic/src/cgic-2.08/cgic.c     | 348 ++++++++++++------------
 extern/ch_cgic/src/cgic-2.08/cgictest.c |  64 ++---
 2 files changed, 206 insertions(+), 206 deletions(-)
 mode change 100644 => 100755 extern/ch_cgic/src/cgic-2.08/cgic.c
 mode change 100644 => 100755 extern/ch_cgic/src/cgic-2.08/cgictest.c

diff --git a/extern/ch_cgic/src/cgic-2.08/cgic.c b/extern/ch_cgic/src/cgic-2.08/cgic.c
old mode 100644
new mode 100755
index 168ae80..75abe14
--- a/extern/ch_cgic/src/cgic-2.08/cgic.c
+++ b/extern/ch_cgic/src/cgic-2.08/cgic.c
@@ -1,9 +1,9 @@
 /* cgicTempDir is the only setting you are likely to need
 	to change in this file. */
 
-/* Used only in Unix environments, in conjunction with mkstemp(). 
-	Elsewhere (Windows), temporary files go where the tmpnam() 
-	function suggests. If this behavior does not work for you, 
+/* Used only in Unix environments, in conjunction with mkstemp().
+	Elsewhere (Windows), temporary files go where the tmpnam()
+	function suggests. If this behavior does not work for you,
 	modify the getTempFile() function to suit your needs. */
 
 #define cgicTempDir "/tmp"
@@ -12,15 +12,15 @@
 #define CGICDEBUG 1
 
 #if CGICDEBUG
-#define CGIC_DEBUG(...)                               				\
-    do {															\
+#define CGIC_DEBUG(...)												\
+	do {															\
 		FILE *dout = fopen("/tmp/cgic_debug.log", "a+");			\
-        fprintf(dout, "===[%ld]=== %s(%s:%d) ",             		\
-                time(NULL), __func__, __FILE__, __LINE__);			\
-        fprintf(dout, __VA_ARGS__);                             	\
-        fprintf(dout, "\n");                                    	\
+		fprintf(dout, "===[%ld]=== %s(%s:%d) ",						\
+				time(NULL), __func__, __FILE__, __LINE__);			\
+		fprintf(dout, __VA_ARGS__);									\
+		fprintf(dout, "\n");										\
 		fclose(dout);												\
-    } while (0)
+	} while (0)
 
 #else /* CGICDEBUG */
 #define CGIC_DEBUG(...)
@@ -92,14 +92,14 @@ typedef enum {
 	these are guaranteed to be valid null-terminated strings,
 	which will be of length zero in the event that the
 	field is not present, with the exception of tfileName
-	which will be null when 'in' is null. DO NOT MODIFY THESE 
+	which will be null when 'in' is null. DO NOT MODIFY THESE
 	VALUES. Make local copies if modifications are desired. */
 
 typedef struct cgiFormEntryStruct {
 	char *attr;
 	/* value is populated for regular form fields only.
 		For file uploads, it points to an empty string, and file
-		upload data should be read from the file tfileName. */ 
+		upload data should be read from the file tfileName. */
 	char *value;
 	/* When fileName is not an empty string, tfileName is not null,
 		and 'value' points to an empty string. */
@@ -111,7 +111,7 @@ typedef struct cgiFormEntryStruct {
 	char *contentType;
 	/* Temporary file descriptor for working storage of file uploads. */
 	FILE *tFile;
-        struct cgiFormEntryStruct *next;
+		struct cgiFormEntryStruct *next;
 } cgiFormEntry;
 
 /* The first form entry. */
@@ -178,7 +178,7 @@ int main(int argc, char *argv[]) {
 			sat++;
 			while (isspace(*sat)) {
 				sat++;
-			}	
+			}
 			if (cgiStrBeginsNc(sat, "boundary=")) {
 				char *s;
 				cgiMultipartBoundary = sat + strlen("boundary=");
@@ -190,18 +190,18 @@ int main(int argc, char *argv[]) {
 				break;
 			} else {
 				sat = strchr(sat, ';');
-			} 	
+			}
 		}
 	}
 	cgiGetenv(&cgiContentLengthString, "CONTENT_LENGTH");
-	cgiContentLength = atoi(cgiContentLengthString);	
+	cgiContentLength = atoi(cgiContentLengthString);
 	cgiGetenv(&cgiAccept, "HTTP_ACCEPT");
 	cgiGetenv(&cgiUserAgent, "HTTP_USER_AGENT");
 	cgiGetenv(&cgiReferrer, "HTTP_REFERER");
 	cgiGetenv(&cgiCookie, "HTTP_COOKIE");
 	CGIC_DEBUG("%d\n", cgiContentLength);
 	CGIC_DEBUG("%s\n", cgiRequestMethod);
-	CGIC_DEBUG("%s\n", cgiContentType);	
+	CGIC_DEBUG("%s\n", cgiContentType);
 #ifdef WIN32
 	/* 1.07: Must set stdin and stdout to binary mode */
 	/* 2.0: this is particularly crucial now and must not be removed */
@@ -221,19 +221,19 @@ int main(int argc, char *argv[]) {
 		if (argv[0]) {
 			cgiRestored = 0;
 		}
-	}	
+	}
 
 
 	if (cgiStrEqNc(cgiRequestMethod, "post")) {
 		CGIC_DEBUG("POST recognized\n");
-		if (cgiStrEqNc(cgiContentType, "application/x-www-form-urlencoded")) {	
-			CGIC_DEBUG("Calling PostFormInput\n");	
+		if (cgiStrEqNc(cgiContentType, "application/x-www-form-urlencoded")) {
+			CGIC_DEBUG("Calling PostFormInput\n");
 			if (cgiParsePostFormInput() != cgiParseSuccess) {
 				CGIC_DEBUG("PostFormInput failed\n");
 				cgiHeaderStatus(500, "Error reading form data");
 				cgiFreeResources();
 				return -1;
-			}	
+			}
 			CGIC_DEBUG("PostFormInput succeeded\n");
 		} else if (cgiStrEqNc(cgiContentType, "multipart/form-data")) {
 			CGIC_DEBUG("Calling PostMultipartInput\n");
@@ -242,10 +242,10 @@ int main(int argc, char *argv[]) {
 				cgiHeaderStatus(500, "Error reading form data");
 				cgiFreeResources();
 				return -1;
-			}	
+			}
 			CGIC_DEBUG("PostMultipartInput succeeded\n");
 		}
-	} else if (cgiStrEqNc(cgiRequestMethod, "get")) {	
+	} else if (cgiStrEqNc(cgiRequestMethod, "get")) {
 		/* The spec says this should be taken care of by
 			the server, but... it isn't */
 		cgiContentLength = strlen(cgiQueryString);
@@ -254,7 +254,7 @@ int main(int argc, char *argv[]) {
 			cgiHeaderStatus(500, "Error reading form data");
 			cgiFreeResources();
 			return -1;
-		} else {	
+		} else {
 			CGIC_DEBUG("GetFormInput succeeded\n");
 		}
 	}
@@ -283,25 +283,25 @@ static cgiParseResultType cgiParsePostFormInput() {
 	}
 	input = (char *) malloc(cgiContentLength);
 	if (!input) {
-		return cgiParseMemory;	
+		return cgiParseMemory;
 	}
-	if (((int) fread(input, 1, cgiContentLength, cgiIn)) 
-		!= cgiContentLength) 
+	if (((int) fread(input, 1, cgiContentLength, cgiIn))
+		!= cgiContentLength)
 	{
 		return cgiParseIO;
-	}	
+	}
 	result = cgiParseFormInput(input, cgiContentLength);
 	free(input);
 	return result;
 }
 
-/* 2.0: A virtual datastream supporting putback of 
+/* 2.0: A virtual datastream supporting putback of
 	enough characters to handle multipart boundaries easily.
 	A simple memset(&mp, 0, sizeof(mp)) is suitable initialization. */
 
 typedef struct {
 	/* Buffer for putting characters back */
-	char putback[1024];	
+	char putback[1024];
 	/* Position in putback from which next character will be read.
 		If readPos == writePos, then next character should
 		come from cgiIn. */
@@ -309,7 +309,7 @@ typedef struct {
 	/* Position in putback to which next character will be put back.
 		If writePos catches up to readPos, as opposed to the other
 		way around, the stream no longer functions properly.
-		Calling code must guarantee that no more than 
+		Calling code must guarantee that no more than
 		sizeof(putback) bytes are put back at any given time. */
 	int writePos;
 	/* Offset in the virtual datastream; can be compared
@@ -334,7 +334,7 @@ int mpRead(mpStreamPtr mpp, char *buffer, int len)
 			len--;
 		} else {
 			break;
-		}	
+		}
 	}
 	if (len) {
 		int fgot = fread(buffer, 1, len, cgiIn);
@@ -351,7 +351,7 @@ int mpRead(mpStreamPtr mpp, char *buffer, int len)
 	} else if (got) {
 		mpp->offset += got;
 		return got;
-	} else if (ilen) {	
+	} else if (ilen) {
 		return EOF;
 	} else {
 		/* 2.01 */
@@ -373,14 +373,14 @@ void mpPutBack(mpStreamPtr mpp, char *data, int len)
 	a newly allocated character buffer at *outP, which will be null
 	terminated; if both outf and outP are null the body is not stored.
 	If bodyLengthP is not null, the size of the body in bytes is stored
-	to *bodyLengthP, not including any terminating null added to *outP. 
+	to *bodyLengthP, not including any terminating null added to *outP.
 	If 'first' is nonzero, a preceding newline is not expected before
 	the boundary. If 'first' is zero, a preceding newline is expected.
-	Upon return mpp is positioned after the boundary and its trailing 
-	newline, if any; if the boundary is followed by -- the next two 
-	characters read after this function returns will be --. Upon error, 
-	if outP is not null, *outP is a null pointer; *bodyLengthP 
-	is set to zero. Returns cgiParseSuccess, cgiParseMemory 
+	Upon return mpp is positioned after the boundary and its trailing
+	newline, if any; if the boundary is followed by -- the next two
+	characters read after this function returns will be --. Upon error,
+	if outP is not null, *outP is a null pointer; *bodyLengthP
+	is set to zero. Returns cgiParseSuccess, cgiParseMemory
 	or cgiParseIO. */
 
 static cgiParseResultType afterNextBoundary(mpStreamPtr mpp,
@@ -391,7 +391,7 @@ static cgiParseResultType afterNextBoundary(mpStreamPtr mpp,
 	);
 
 static int readHeaderLine(
-	mpStreamPtr mpp,	
+	mpStreamPtr mpp,
 	char *attr,
 	int attrSpace,
 	char *value,
@@ -419,7 +419,7 @@ static cgiParseResultType cgiParsePostMultipartInput() {
 	}
 	/* Read first boundary, including trailing newline */
 	result = afterNextBoundary(mpp, 0, 0, 0, 1);
-	if (result == cgiParseIO) {	
+	if (result == cgiParseIO) {
 		/* An empty submission is not necessarily an error */
 		return cgiParseSuccess;
 	} else if (result != cgiParseSuccess) {
@@ -454,11 +454,11 @@ static cgiParseResultType cgiParsePostMultipartInput() {
 		mpPutBack(mpp, d, 2);
 		/* Read header lines until end of header */
 		while (readHeaderLine(
-				mpp, attr, sizeof(attr), value, sizeof(value))) 
+				mpp, attr, sizeof(attr), value, sizeof(value)))
 		{
 			char *argNames[3];
 			char *argValues[2];
-			/* Content-Disposition: form-data; 
+			/* Content-Disposition: form-data;
 				name="test"; filename="googley.gif" */
 			if (cgiStrEqNc(attr, "Content-Disposition")) {
 				argNames[0] = "name";
@@ -466,14 +466,14 @@ static cgiParseResultType cgiParsePostMultipartInput() {
 				argNames[2] = 0;
 				argValues[0] = fname;
 				argValues[1] = ffileName;
-				decomposeValue(value, 
+				decomposeValue(value,
 					fvalue, sizeof(fvalue),
 					argNames,
 					argValues,
-					1024);	
+					1024);
 			} else if (cgiStrEqNc(attr, "Content-Type")) {
 				argNames[0] = 0;
-				decomposeValue(value, 
+				decomposeValue(value,
 					fcontentType, sizeof(fcontentType),
 					argNames,
 					0,
@@ -481,7 +481,7 @@ static cgiParseResultType cgiParsePostMultipartInput() {
 			}
 		}
 		if (!cgiStrEqNc(fvalue, "form-data")) {
-			/* Not form data */	
+			/* Not form data */
 			result = afterNextBoundary(mpp, 0, 0, 0, 0);
 			if (result != cgiParseSuccess) {
 				/* Lack of a boundary here is an error. */
@@ -489,8 +489,8 @@ static cgiParseResultType cgiParsePostMultipartInput() {
 			}
 			continue;
 		}
-		/* Body is everything from here until the next 
-			boundary. So, set it aside and move past boundary. 
+		/* Body is everything from here until the next
+			boundary. So, set it aside and move past boundary.
 			If a filename was submitted as part of the
 			disposition header, store to a temporary file.
 			Otherwise, store to a memory buffer (it is
@@ -505,7 +505,7 @@ static cgiParseResultType cgiParsePostMultipartInput() {
 			#endif
 		} else {
 			outf = 0;
-		}	
+		}
 		result = afterNextBoundary(mpp, outf, &out, &bodyLength, 0);
 		if (result != cgiParseSuccess) {
 			/* Lack of a boundary here is an error. */
@@ -518,7 +518,7 @@ static cgiParseResultType cgiParsePostMultipartInput() {
 			return result;
 		}
 		/* OK, we have a new pair, add it to the list. */
-		n = (cgiFormEntry *) malloc(sizeof(cgiFormEntry));	
+		n = (cgiFormEntry *) malloc(sizeof(cgiFormEntry));
 		if (!n) {
 			goto outOfMemory;
 		}
@@ -570,8 +570,8 @@ static cgiParseResultType cgiParsePostMultipartInput() {
 			fclose(outf);
 		}
 
-		l = n;			
-	}	
+		l = n;
+	}
 	return cgiParseSuccess;
 outOfMemory:
 	if (n) {
@@ -619,13 +619,13 @@ static cgiParseResultType getTempFile(FILE **tFile, char *fullFileName)
 #ifndef WIN32
 	/* Unix. Use the robust 'mkstemp' function to create
 		a temporary file that is truly unique, with
-		permissions that are truly safe. The 
+		permissions that are truly safe. The
 		fopen-for-write destroys any bogus information
 		written by potential hackers during the brief
 		window between the file's creation and the
 		chmod call (glibc 2.0.6 and lower might
 		otherwise have allowed this). */
-	int outfd; 
+	int outfd;
 	strcpy(tfileName, cgicTempDir "/cgicXXXXXX");
 	outfd = mkstemp(tfileName);
 	if (outfd == -1) {
@@ -672,7 +672,7 @@ static cgiParseResultType getTempFile(FILE **tFile, char *fullFileName)
 		} \
 		string[string##Len++] = (ch); \
 	}
-		
+
 #define BAPPEND(ch) \
 	{ \
 		if (outf) { \
@@ -692,7 +692,7 @@ cgiParseResultType afterNextBoundary(mpStreamPtr mpp, FILE *outf, char **outP,
 	cgiParseResultType result;
 	int boffset;
 	int got;
-	char d[2];	
+	char d[2];
 	/* This is large enough, because the buffer into which the
 		original boundary string is fetched is shorter by more
 		than four characters due to the space required for
@@ -726,21 +726,21 @@ cgiParseResultType afterNextBoundary(mpStreamPtr mpp, FILE *outf, char **outP,
 			boffset++;
 			if (boffset == workingBoundaryLength) {
 				break;
-			} 
+			}
 		} else if (boffset > 0) {
 			/* We matched part, but not all, of the
 				boundary. Now we have to be careful:
 				put back all except the first
-				character and try again. The 
+				character and try again. The
 				real boundary could begin in the
 				middle of a false match. We can
 				emit the first character only so far. */
 			BAPPEND(workingBoundary[0]);
-			mpPutBack(mpp, 
+			mpPutBack(mpp,
 				workingBoundary + 1, boffset - 1);
 			mpPutBack(mpp, d, 1);
 			boffset = 0;
-		} else {		
+		} else {
 			/* Not presently in the middle of a boundary
 				match; just emit the character. */
 			BAPPEND(d[0]);
@@ -755,14 +755,14 @@ cgiParseResultType afterNextBoundary(mpStreamPtr mpp, FILE *outf, char **outP,
 	if (got != 2) {
 		result = cgiParseIO;
 		goto error;
-	}	
+	}
 	if ((d[0] == '\r') && (d[1] == '\n')) {
 		/* OK, EOL */
 	} else if (d[0] == '-') {
 		/* Probably EOF, but we check for
 			that later */
 		mpPutBack(mpp, d, 2);
-	}	
+	}
 	if (out && outSpace) {
 		char *oout = out;
 		out[outLen] = '\0';
@@ -785,7 +785,7 @@ outOfMemory:
 		if (out) {
 			free(out);
 		}
-		*outP = 0;	
+		*outP = 0;
 	}
 error:
 	if (bodyLengthP) {
@@ -795,7 +795,7 @@ error:
 		free(out);
 	}
 	if (outP) {
-		*outP = 0;	
+		*outP = 0;
 	}
 	return result;
 }
@@ -836,8 +836,8 @@ static void decomposeValue(char *value,
 		while ((*value) && (*value != ';')) {
 			APPEND(mvalue, *value);
 			value++;
-		}	
-	}	
+		}
+	}
 	if (mvalueSpace) {
 		mvalue[mvalueLen] = '\0';
 	}
@@ -847,7 +847,7 @@ static void decomposeValue(char *value,
 		/* Skip the ; between parameters */
 		value++;
 		/* Now skip leading whitespace */
-		while ((*value) && (isspace(*value))) { 
+		while ((*value) && (isspace(*value))) {
 			value++;
 		}
 		/* Now read the parameter name */
@@ -864,7 +864,7 @@ static void decomposeValue(char *value,
 		}
 		if (*value != '=') {
 			/* Malformed line */
-			return;	
+			return;
 		}
 		value++;
 		while ((*value) && isspace(*value)) {
@@ -879,7 +879,7 @@ static void decomposeValue(char *value,
 				break;
 			}
 			argNum++;
-		}		
+		}
 		/* Finally, read the parameter value */
 		if (*value == '\"') {
 			value++;
@@ -899,14 +899,14 @@ static void decomposeValue(char *value,
 					APPEND(argValue, *value);
 				}
 				value++;
-			}	
-		}	
+			}
+		}
 		if (argValueSpace) {
 			if (argValue) {
 				argValue[argValueLen] = '\0';
 			}
 		}
-	}	 	
+	}
 }
 
 static int readHeaderLine(
@@ -915,19 +915,19 @@ static int readHeaderLine(
 	int attrSpace,
 	char *value,
 	int valueSpace)
-{	
+{
 	int attrLen = 0;
 	int valueLen = 0;
 	int valueFound = 0;
 	while (1) {
 		char d[1];
 		int got = mpRead(mpp, d, 1);
-		if (got != 1) {	
+		if (got != 1) {
 			return 0;
 		}
 		if (d[0] == '\r') {
 			got = mpRead(mpp, d, 1);
-			if (got == 1) {	
+			if (got == 1) {
 				if (d[0] == '\n') {
 					/* OK */
 				} else {
@@ -943,15 +943,15 @@ static int readHeaderLine(
 				if (!isspace(d[0])) {
 					mpPutBack(mpp, d, 1);
 					break;
-				} 
+				}
 			}
 		} else if (!valueFound) {
 			if (!isspace(*d)) {
 				if (attrLen < (attrSpace - 1)) {
 					attr[attrLen++] = *d;
 				}
-			}		
-		} else if (valueFound) {	
+			}
+		} else if (valueFound) {
 			if (valueLen < (valueSpace - 1)) {
 				value[valueLen++] = *d;
 			}
@@ -1017,7 +1017,7 @@ static cgiParseResultType cgiParseFormInput(char *data, int length) {
 		if (cgiUnescapeChars(&attr, data+start, len)
 			!= cgiUnescapeSuccess) {
 			return cgiParseMemory;
-		}	
+		}
 		start = pos;
 		len = 0;
 		while (pos != length) {
@@ -1035,9 +1035,9 @@ static cgiParseResultType cgiParseFormInput(char *data, int length) {
 			!= cgiUnescapeSuccess) {
 			free(attr);
 			return cgiParseMemory;
-		}	
+		}
 		/* OK, we have a new pair, add it to the list. */
-		n = (cgiFormEntry *) malloc(sizeof(cgiFormEntry));	
+		n = (cgiFormEntry *) malloc(sizeof(cgiFormEntry));
 		if (!n) {
 			free(attr);
 			free(value);
@@ -1052,7 +1052,7 @@ static cgiParseResultType cgiParseFormInput(char *data, int length) {
 			free(value);
 			free(n);
 			return cgiParseMemory;
-		}	
+		}
 		n->fileName[0] = '\0';
 		n->contentType = (char *) malloc(1);
 		if (!n->contentType) {
@@ -1061,7 +1061,7 @@ static cgiParseResultType cgiParseFormInput(char *data, int length) {
 			free(n->fileName);
 			free(n);
 			return cgiParseMemory;
-		}	
+		}
 		n->contentType[0] = '\0';
 		n->next = 0;
 		if (!l) {
@@ -1072,7 +1072,7 @@ static cgiParseResultType cgiParseFormInput(char *data, int length) {
 		l = n;
 		if (!foundAmp) {
 			break;
-		}			
+		}
 	}
 	return cgiParseSuccess;
 }
@@ -1098,11 +1098,11 @@ cgiUnescapeResultType cgiUnescapeChars(char **sp, char *cp, int len) {
 			} else if (ch == '+') {
 				s[dstPos++] = ' ';
 			} else {
-				s[dstPos++] = ch;	
+				s[dstPos++] = ch;
 			}
 			break;
 			case cgiEscapeFirst:
-			escapedValue = cgiHexValue[ch] << 4;	
+			escapedValue = cgiHexValue[ch] << 4;
 			escapeState = cgiEscapeSecond;
 			break;
 			case cgiEscapeSecond:
@@ -1116,22 +1116,22 @@ cgiUnescapeResultType cgiUnescapeChars(char **sp, char *cp, int len) {
 	s[dstPos] = '\0';
 	*sp = s;
 	return cgiUnescapeSuccess;
-}		
-	
+}
+
 static void cgiSetupConstants() {
 	int i;
 	for (i=0; (i < 256); i++) {
 		cgiHexValue[i] = 0;
 	}
-	cgiHexValue['0'] = 0;	
-	cgiHexValue['1'] = 1;	
-	cgiHexValue['2'] = 2;	
-	cgiHexValue['3'] = 3;	
-	cgiHexValue['4'] = 4;	
-	cgiHexValue['5'] = 5;	
-	cgiHexValue['6'] = 6;	
-	cgiHexValue['7'] = 7;	
-	cgiHexValue['8'] = 8;	
+	cgiHexValue['0'] = 0;
+	cgiHexValue['1'] = 1;
+	cgiHexValue['2'] = 2;
+	cgiHexValue['3'] = 3;
+	cgiHexValue['4'] = 4;
+	cgiHexValue['5'] = 5;
+	cgiHexValue['6'] = 6;
+	cgiHexValue['7'] = 7;
+	cgiHexValue['8'] = 8;
 	cgiHexValue['9'] = 9;
 	cgiHexValue['A'] = 10;
 	cgiHexValue['B'] = 11;
@@ -1198,7 +1198,7 @@ static cgiFormEntry *cgiFormEntryFindFirst(char *name);
 static cgiFormEntry *cgiFormEntryFindNext();
 
 cgiFormResultType cgiFormString(
-        char *name, char *result, int max) {
+		char *name, char *result, int max) {
 	cgiFormEntry *e;
 	e = cgiFormEntryFindFirst(name);
 	if (!e) {
@@ -1223,7 +1223,7 @@ cgiFormResultType cgiFormFileName(
 	while (*s) {
 		APPEND(result, *s);
 		s++;
-	}	
+	}
 	if (resultSpace) {
 		result[resultLen] = '\0';
 	}
@@ -1251,7 +1251,7 @@ cgiFormResultType cgiFormFileFullName(
 	while (*s) {
 		APPEND(result, *s);
 		s++;
-	}	
+	}
 	if (resultSpace) {
 		result[resultLen] = '\0';
 	}
@@ -1291,14 +1291,14 @@ cgiFormResultType cgiFormFileContentType(
 	if (!e) {
 		if (resultSpace) {
 			result[0] = '\0';
-		}	
+		}
 		return cgiFormNotFound;
 	}
 	s = e->contentType;
 	while (*s) {
 		APPEND(result, *s);
 		s++;
-	}	
+	}
 	if (resultSpace) {
 		result[resultLen] = '\0';
 	}
@@ -1368,7 +1368,7 @@ cgiFormResultType cgiFormFileOpen(
 }
 
 cgiFormResultType cgiFormFileRead(
-	cgiFilePtr cfp, char *buffer, 
+	cgiFilePtr cfp, char *buffer,
 	int bufferSize, int *gotP)
 {
 	int got = 0;
@@ -1394,7 +1394,7 @@ cgiFormResultType cgiFormFileClose(cgiFilePtr cfp)
 }
 
 cgiFormResultType cgiFormStringNoNewlines(
-        char *name, char *result, int max) {
+		char *name, char *result, int max) {
 	cgiFormEntry *e;
 	e = cgiFormEntryFindFirst(name);
 	if (!e) {
@@ -1405,7 +1405,7 @@ cgiFormResultType cgiFormStringNoNewlines(
 }
 
 cgiFormResultType cgiFormStringMultiple(
-        char *name, char ***result) {
+		char *name, char ***result) {
 	char **stringArray;
 	cgiFormEntry *e;
 	int i;
@@ -1417,7 +1417,7 @@ cgiFormResultType cgiFormStringMultiple(
 	if (e != 0) {
 		do {
 			total++;
-		} while ((e = cgiFormEntryFindNext()) != 0); 
+		} while ((e = cgiFormEntryFindNext()) != 0);
 	}
 	stringArray = (char **) malloc(sizeof(char *) * (total + 1));
 	if (!stringArray) {
@@ -1441,11 +1441,11 @@ cgiFormResultType cgiFormStringMultiple(
 				cgiStringArrayFree(stringArray);
 				*result = 0;
 				return cgiFormMemory;
-			}	
+			}
 			strcpy(stringArray[i], e->value);
 			cgiFormEntryString(e, stringArray[i], max, 1);
 			i++;
-		} while ((e = cgiFormEntryFindNext()) != 0); 
+		} while ((e = cgiFormEntryFindNext()) != 0);
 		*result = stringArray;
 		CGIC_DEBUG("StringMultiple Succeeding\n");
 		return cgiFormSuccess;
@@ -1457,12 +1457,12 @@ cgiFormResultType cgiFormStringMultiple(
 }
 
 cgiFormResultType cgiFormStringSpaceNeeded(
-        char *name, int *result) {
+		char *name, int *result) {
 	cgiFormEntry *e;
 	e = cgiFormEntryFindFirst(name);
 	if (!e) {
 		*result = 1;
-		return cgiFormNotFound; 
+		return cgiFormNotFound;
 	}
 	*result = ((int) strlen(e->value)) + 1;
 	return cgiFormSuccess;
@@ -1475,9 +1475,9 @@ static cgiFormResultType cgiFormEntryString(
 	int len = 0;
 	int avail = max-1;
 	int crCount = 0;
-	int lfCount = 0;	
+	int lfCount = 0;
 	dp = result;
-	sp = e->value;	
+	sp = e->value;
 	while (1) {
 		int ch;
 		/* 1.07: don't check for available space now.
@@ -1488,7 +1488,7 @@ static cgiFormResultType cgiFormEntryString(
 		ch = *sp;
 		/* Fix the CR/LF, LF, CR nightmare: watch for
 			consecutive bursts of CRs and LFs in whatever
-			pattern, then actually output the larger number 
+			pattern, then actually output the larger number
 			of LFs. Consistently sane, yet it still allows
 			consecutive blank lines when the user
 			actually intends them. */
@@ -1497,7 +1497,7 @@ static cgiFormResultType cgiFormEntryString(
 				crCount++;
 			} else {
 				lfCount++;
-			}	
+			}
 		} else {
 			if (crCount || lfCount) {
 				int lfsAdd = crCount;
@@ -1516,15 +1516,15 @@ static cgiFormResultType cgiFormEntryString(
 					*dp = 10;
 					dp++;
 					lfsAdd--;
-					len++;		
+					len++;
 				}
 				crCount = 0;
 				lfCount = 0;
 			}
 			if (ch == '\0') {
 				/* The end of the source string */
-				break;				
-			}	
+				break;
+			}
 			/* 1.06: check available space before adding
 				the character, because a previously added
 				LF may have brought us to the limit */
@@ -1536,8 +1536,8 @@ static cgiFormResultType cgiFormEntryString(
 			dp++;
 			len++;
 		}
-		sp++;	
-	}	
+		sp++;
+	}
 	*dp = '\0';
 	if (truncated) {
 		return cgiFormTruncated;
@@ -1551,14 +1551,14 @@ static cgiFormResultType cgiFormEntryString(
 static int cgiFirstNonspaceChar(char *s);
 
 cgiFormResultType cgiFormInteger(
-        char *name, int *result, int defaultV) {
+		char *name, int *result, int defaultV) {
 	cgiFormEntry *e;
 	int ch;
 	e = cgiFormEntryFindFirst(name);
 	if (!e) {
 		*result = defaultV;
-		return cgiFormNotFound; 
-	}	
+		return cgiFormNotFound;
+	}
 	if (!strlen(e->value)) {
 		*result = defaultV;
 		return cgiFormEmpty;
@@ -1574,7 +1574,7 @@ cgiFormResultType cgiFormInteger(
 }
 
 cgiFormResultType cgiFormIntegerBounded(
-        char *name, int *result, int min, int max, int defaultV) {
+		char *name, int *result, int min, int max, int defaultV) {
 	cgiFormResultType error = cgiFormInteger(name, result, defaultV);
 	if (error != cgiFormSuccess) {
 		return error;
@@ -1582,27 +1582,27 @@ cgiFormResultType cgiFormIntegerBounded(
 	if (*result < min) {
 		*result = min;
 		return cgiFormConstrained;
-	} 
+	}
 	if (*result > max) {
 		*result = max;
 		return cgiFormConstrained;
-	} 
+	}
 	return cgiFormSuccess;
 }
 
 cgiFormResultType cgiFormDouble(
-        char *name, double *result, double defaultV) {
+		char *name, double *result, double defaultV) {
 	cgiFormEntry *e;
 	int ch;
 	e = cgiFormEntryFindFirst(name);
 	if (!e) {
 		*result = defaultV;
-		return cgiFormNotFound; 
-	}	
+		return cgiFormNotFound;
+	}
 	if (!strlen(e->value)) {
 		*result = defaultV;
 		return cgiFormEmpty;
-	} 
+	}
 	ch = cgiFirstNonspaceChar(e->value);
 	if (!(isdigit(ch)) && (ch != '.') && (ch != '-') && (ch != '+')) {
 		*result = defaultV;
@@ -1614,7 +1614,7 @@ cgiFormResultType cgiFormDouble(
 }
 
 cgiFormResultType cgiFormDoubleBounded(
-        char *name, double *result, double min, double max, double defaultV) {
+		char *name, double *result, double min, double max, double defaultV) {
 	cgiFormResultType error = cgiFormDouble(name, result, defaultV);
 	if (error != cgiFormSuccess) {
 		return error;
@@ -1622,17 +1622,17 @@ cgiFormResultType cgiFormDoubleBounded(
 	if (*result < min) {
 		*result = min;
 		return cgiFormConstrained;
-	} 
+	}
 	if (*result > max) {
 		*result = max;
 		return cgiFormConstrained;
-	} 
+	}
 	return cgiFormSuccess;
 }
 
 cgiFormResultType cgiFormSelectSingle(
-	char *name, char **choicesText, int choicesTotal, 
-	int *result, int defaultV) 
+	char *name, char **choicesText, int choicesTotal,
+	int *result, int defaultV)
 {
 	cgiFormEntry *e;
 	int i;
@@ -1655,8 +1655,8 @@ cgiFormResultType cgiFormSelectSingle(
 }
 
 cgiFormResultType cgiFormSelectMultiple(
-	char *name, char **choicesText, int choicesTotal, 
-	int *result, int *invalid) 
+	char *name, char **choicesText, int choicesTotal,
+	int *result, int *invalid)
 {
 	cgiFormEntry *e;
 	int i;
@@ -1706,20 +1706,20 @@ cgiFormResultType cgiFormCheckboxSingle(
 }
 
 extern cgiFormResultType cgiFormCheckboxMultiple(
-	char *name, char **valuesText, int valuesTotal, 
+	char *name, char **valuesText, int valuesTotal,
 	int *result, int *invalid)
 {
 	/* Implementation is identical to cgiFormSelectMultiple. */
-	return cgiFormSelectMultiple(name, valuesText, 
+	return cgiFormSelectMultiple(name, valuesText,
 		valuesTotal, result, invalid);
 }
 
 cgiFormResultType cgiFormRadio(
-	char *name, 
+	char *name,
 	char **valuesText, int valuesTotal, int *result, int defaultV)
 {
 	/* Implementation is identical to cgiFormSelectSingle. */
-	return cgiFormSelectSingle(name, valuesText, valuesTotal, 
+	return cgiFormSelectSingle(name, valuesText, valuesTotal,
 		result, defaultV);
 }
 
@@ -1733,9 +1733,9 @@ cgiFormResultType cgiCookieString(
 		char *n = name;
 		/* 2.02: if cgiCookie is exactly equal to name, this
 			can cause an overrun. The server probably wouldn't
-			allow it, since a name without values makes no sense 
+			allow it, since a name without values makes no sense
 			-- but then again it might not check, so this is a
-			genuine security concern. Thanks to Nicolas 
+			genuine security concern. Thanks to Nicolas
 			Tomadakis. */
 		while (*p == *n) {
 			if ((*p == '\0') && (*n == '\0')) {
@@ -1748,7 +1748,7 @@ cgiFormResultType cgiCookieString(
 		if ((!*n) && (*p == '=')) {
 			p++;
 			while ((*p != ';') && (*p != '\0') &&
-				(space > 1)) 
+				(space > 1))
 			{
 				*value = *p;
 				value++;
@@ -1763,11 +1763,11 @@ cgiFormResultType cgiCookieString(
 			if (!(((*p) == ';') || ((*p) == '\0')))
 			{
 				return cgiFormTruncated;
-			} else {	
+			} else {
 				return cgiFormSuccess;
 			}
 		} else {
-			/* Skip to next cookie */	
+			/* Skip to next cookie */
 			while (*p) {
 				if (*p == ';') {
 					break;
@@ -1781,11 +1781,11 @@ cgiFormResultType cgiCookieString(
 				}
 				return cgiFormNotFound;
 			}
-			p++;	
+			p++;
 			/* Allow whitespace after semicolon */
 			while ((*p) && isspace(*p)) {
 				p++;
-			} 
+			}
 		}
 	}
 	/* 2.01: actually the above loop never terminates except
@@ -1803,7 +1803,7 @@ cgiFormResultType cgiCookieInteger(
 	int defaultV)
 {
 	char buffer[256];
-	cgiFormResultType r = 
+	cgiFormResultType r =
 		cgiCookieString(name, buffer, sizeof(buffer));
 	if (r != cgiFormSuccess) {
 		*result = defaultV;
@@ -1850,14 +1850,14 @@ void cgiHeaderCookieSet(char *name, char *value, int secondsToLive,
 	char *path, char *domain, int options)
 {
 	/* cgic 2.02: simpler and more widely compatible implementation.
-		Thanks to Chunfu Lai. 
+		Thanks to Chunfu Lai.
 	   cgic 2.03: yes, but it didn't work. Reimplemented by
-		Thomas Boutell. ; after last element was a bug. 
+		Thomas Boutell. ; after last element was a bug.
 	   Examples of real world cookies that really work:
-   	   Set-Cookie: MSNADS=UM=; domain=.slate.com; 
-             expires=Tue, 26-Apr-2022 19:00:00 GMT; path=/
-	   Set-Cookie: MC1=V=3&ID=b5bc08af2b8a43ff85fcb5efd8b238f0; 
-             domain=.slate.com; expires=Mon, 04-Oct-2021 19:00:00 GMT; path=/
+	   Set-Cookie: MSNADS=UM=; domain=.slate.com;
+			 expires=Tue, 26-Apr-2022 19:00:00 GMT; path=/
+	   Set-Cookie: MC1=V=3&ID=b5bc08af2b8a43ff85fcb5efd8b238f0;
+			 domain=.slate.com; expires=Mon, 04-Oct-2021 19:00:00 GMT; path=/
 	*/
 	time_t now;
 	time_t then;
@@ -1865,13 +1865,13 @@ void cgiHeaderCookieSet(char *name, char *value, int secondsToLive,
 	time(&now);
 	then = now + secondsToLive;
 	gt = gmtime(&then);
-	fprintf(cgiOut, 
+	fprintf(cgiOut,
 		"Set-Cookie: %s=%s; domain=%s; expires=%s, %02d-%s-%04d %02d:%02d:%02d GMT; path=%s%s%s%s\r\n",
-		name, value, domain, 
+		name, value, domain,
 		days[gt->tm_wday],
 		gt->tm_mday,
 		months[gt->tm_mon],
-		gt->tm_year + 1900, 	
+		gt->tm_year + 1900,
 		gt->tm_hour,
 		gt->tm_min,
 		gt->tm_sec,
@@ -2006,7 +2006,7 @@ cgiEnvironmentResultType cgiWriteEnvironment(char *filename) {
 				cgiFormFileClose(fp);
 				goto error;
 			}
-			while (cgiFormFileRead(fp, buffer, 
+			while (cgiFormFileRead(fp, buffer,
 				sizeof(buffer), &got) == cgiFormSuccess)
 			{
 				if (((int) fwrite(buffer, 1, got, out)) != got) {
@@ -2029,7 +2029,7 @@ cgiEnvironmentResultType cgiWriteEnvironment(char *filename) {
 error:
 	fclose(out);
 	/* If this function is not defined in your system,
-		you must substitute the appropriate 
+		you must substitute the appropriate
 		file-deletion function. */
 	unlink(filename);
 	return cgiEnvironmentIO;
@@ -2076,7 +2076,7 @@ cgiEnvironmentResultType cgiReadEnvironment(char *filename) {
 		/* 2.02: Merezko Oleg */
 		free(version);
 		return cgiEnvironmentWrongVersion;
-	}	
+	}
 	/* 2.02: Merezko Oleg */
 	free(version);
 	if (!cgiReadString(in, &cgiServerSoftware)) {
@@ -2185,7 +2185,7 @@ cgiEnvironmentResultType cgiReadEnvironment(char *filename) {
 				result = cgiEnvironmentIO;
 				goto error;
 			}
-			while (len > 0) {		
+			while (len > 0) {
 				/* 2.01: try is a bad variable name in
 					C++, and it wasn't being used
 					properly either */
@@ -2210,13 +2210,13 @@ cgiEnvironmentResultType cgiReadEnvironment(char *filename) {
 			e->tFile = out;
 		} else {
 			e->tFile = NULL;
-		}	
+		}
 		e->next = 0;
 		if (p) {
 			p->next = e;
 		} else {
 			cgiFormEntryFirst = e;
-		}	
+		}
 		p = e;
 	}
 	fclose(in);
@@ -2250,14 +2250,14 @@ error:
 
 static int cgiReadString(FILE *in, char **s) {
 	int len;
-	/* 2.0 fix: test cgiReadInt for failure! */ 
+	/* 2.0 fix: test cgiReadInt for failure! */
 	if (!cgiReadInt(in, &len)) {
 		return 0;
 	}
 	*s = (char *) malloc(len + 1);
 	if (!(*s)) {
 		return 0;
-	}	
+	}
 	if (((int) fread(*s, 1, len, in)) != len) {
 		return 0;
 	}
@@ -2350,7 +2350,7 @@ void cgiStringArrayFree(char **stringArray) {
 	}
 	/* 2.0: free the array itself! */
 	free(arrayItself);
-}	
+}
 
 cgiFormResultType cgiCookies(char ***result) {
 	char **stringArray;
@@ -2390,13 +2390,13 @@ cgiFormResultType cgiCookies(char ***result) {
 				cgiStringArrayFree(stringArray);
 				*result = 0;
 				return cgiFormMemory;
-			}	
+			}
 			memcpy(stringArray[i], n, p - n);
 			stringArray[i][p - n] = '\0';
 			i++;
 		}
 		while (*p && (*p != ';')) {
-			p++;	
+			p++;
 		}
 		if (!*p) {
 			break;
@@ -2423,7 +2423,7 @@ cgiFormResultType cgiFormEntries(char ***result) {
 			if (!strcmp(e->attr, pe->attr)) {
 				goto skipSecondValue;
 			}
-			pe = pe->next;					
+			pe = pe->next;
 		}
 		total++;
 skipSecondValue:
@@ -2450,8 +2450,8 @@ skipSecondValue:
 			if (!strcmp(e->attr, pe->attr)) {
 				goto skipSecondValue2;
 			}
-			pe = pe->next;					
-		}		
+			pe = pe->next;
+		}
 		space = strlen(e->attr) + 1;
 		stringArray[i] = (char *) malloc(space);
 		if (stringArray[i] == 0) {
@@ -2459,7 +2459,7 @@ skipSecondValue:
 			cgiStringArrayFree(stringArray);
 			*result = 0;
 			return cgiFormMemory;
-		}	
+		}
 		strcpy(stringArray[i], e->attr);
 		i++;
 skipSecondValue2:
@@ -2474,7 +2474,7 @@ skipSecondValue2:
 		if (putc((ch), cgiOut) == EOF) { \
 			return cgiFormIO; \
 		} \
-	} 
+	}
 
 cgiFormResultType cgiHtmlEscapeData(const char *data, int len)
 {
diff --git a/extern/ch_cgic/src/cgic-2.08/cgictest.c b/extern/ch_cgic/src/cgic-2.08/cgictest.c
old mode 100644
new mode 100755
index 68c6399..8381bf2
--- a/extern/ch_cgic/src/cgic-2.08/cgictest.c
+++ b/extern/ch_cgic/src/cgic-2.08/cgictest.c
@@ -9,7 +9,7 @@
 
 /* You may need to change this, particularly under Windows;
 	it is a reasonable guess as to an acceptable place to
-	store a saved environment in order to test that feature. 
+	store a saved environment in order to test that feature.
 	If that feature is not important to you, you needn't
 	concern yourself with this. */
 
@@ -60,7 +60,7 @@ int cgiMain() {
 	fprintf(cgiOut, "<HTML><HEAD>\n");
 	fprintf(cgiOut, "<TITLE>cgic test</TITLE></HEAD>\n");
 	fprintf(cgiOut, "<BODY><H1>cgic test</H1>\n");
-	/* If a submit button has already been clicked, act on the 
+	/* If a submit button has already been clicked, act on the
 		submission of the form. */
 	if ((cgiFormSubmitClicked("testcgic") == cgiFormSuccess) ||
 		cgiFormSubmitClicked("saveenvironment") == cgiFormSuccess)
@@ -104,7 +104,7 @@ void Name() {
 	cgiHtmlEscape(name);
 	fprintf(cgiOut, "<BR>\n");
 }
-	
+
 void Address() {
 	char address[241];
 	cgiFormString("address", address, 241);
@@ -120,13 +120,13 @@ void Hungry() {
 		fprintf(cgiOut, "I'm Not Hungry!<BR>\n");
 	}
 }
-	
+
 void Temperature() {
 	double temperature;
 	cgiFormDoubleBounded("temperature", &temperature, 80.0, 120.0, 98.6);
 	fprintf(cgiOut, "My temperature is %f.<BR>\n", temperature);
 }
-	
+
 void Frogs() {
 	int frogsEaten;
 	cgiFormInteger("frogs", &frogsEaten, 0);
@@ -143,7 +143,7 @@ void Color() {
 	int colorChoice;
 	cgiFormSelectSingle("colors", colors, 3, &colorChoice, 0);
 	fprintf(cgiOut, "I am: %s<BR>\n", colors[colorChoice]);
-}	 
+}
 
 char *flavors[] = {
 	"pistachio",
@@ -154,13 +154,13 @@ char *flavors[] = {
 void Flavors() {
 	int flavorChoices[3];
 	int i;
-	int result;	
+	int result;
 	int invalid;
-	result = cgiFormSelectMultiple("flavors", flavors, 3, 
+	result = cgiFormSelectMultiple("flavors", flavors, 3,
 		flavorChoices, &invalid);
 	if (result == cgiFormNotFound) {
 		fprintf(cgiOut, "I hate ice cream.<p>\n");
-	} else {	
+	} else {
 		fprintf(cgiOut, "My favorite ice cream flavors are:\n");
 		fprintf(cgiOut, "<ul>\n");
 		for (i=0; (i < 3); i++) {
@@ -182,12 +182,12 @@ char *ages[] = {
 void RadioButtons() {
 	int ageChoice;
 	char ageText[10];
-	/* Approach #1: check for one of several valid responses. 
+	/* Approach #1: check for one of several valid responses.
 		Good if there are a short list of possible button values and
 		you wish to enumerate them. */
 	cgiFormRadio("age", ages, 4, &ageChoice, 0);
 
-	fprintf(cgiOut, "Age of Truck: %s (method #1)<BR>\n", 
+	fprintf(cgiOut, "Age of Truck: %s (method #1)<BR>\n",
 		ages[ageChoice]);
 
 	/* Approach #2: just get the string. Good
@@ -195,7 +195,7 @@ void RadioButtons() {
 		to verify it in some other way. Note that if
 		the information is numeric, cgiFormInteger,
 		cgiFormDouble, and related functions may be
-		used instead of cgiFormString. */	
+		used instead of cgiFormString. */
 	cgiFormString("age", ageText, 10);
 
 	fprintf(cgiOut, "Age of Truck: %s (method #2)<BR>\n", ageText);
@@ -211,7 +211,7 @@ char *votes[] = {
 void NonExButtons() {
 	int voteChoices[4];
 	int i;
-	int result;	
+	int result;
 	int invalid;
 
 	char **responses;
@@ -220,11 +220,11 @@ void NonExButtons() {
 		since votes for nonexistent candidates should probably
 		be discounted... */
 	fprintf(cgiOut, "Votes (method 1):<BR>\n");
-	result = cgiFormCheckboxMultiple("vote", votes, 4, 
+	result = cgiFormCheckboxMultiple("vote", votes, 4,
 		voteChoices, &invalid);
 	if (result == cgiFormNotFound) {
 		fprintf(cgiOut, "I hate them all!<p>\n");
-	} else {	
+	} else {
 		fprintf(cgiOut, "My preferred candidates are:\n");
 		fprintf(cgiOut, "<ul>\n");
 		for (i=0; (i < 4); i++) {
@@ -241,7 +241,7 @@ void NonExButtons() {
 		or can be checked in some other way. */
 	fprintf(cgiOut, "Votes (method 2):<BR>\n");
 	result = cgiFormStringMultiple("vote", &responses);
-	if (result == cgiFormNotFound) {	
+	if (result == cgiFormNotFound) {
 		fprintf(cgiOut, "I hate them all!<p>\n");
 	} else {
 		int i = 0;
@@ -256,7 +256,7 @@ void NonExButtons() {
 	/* We must be sure to free the string array or a memory
 		leak will occur. Simply calling free() would free
 		the array but not the individual strings. The
-		function cgiStringArrayFree() does the job completely. */	
+		function cgiStringArrayFree() does the job completely. */
 	cgiStringArrayFree(responses);
 }
 
@@ -302,20 +302,20 @@ void Cookies()
 		arrayStep++;
 	}
 	fprintf(cgiOut, "</table>\n");
-	cgiFormString("cname", cname, sizeof(cname));	
-	cgiFormString("cvalue", cvalue, sizeof(cvalue));	
+	cgiFormString("cname", cname, sizeof(cname));
+	cgiFormString("cvalue", cvalue, sizeof(cvalue));
 	if (strlen(cname)) {
 		fprintf(cgiOut, "New Cookie Set On This Call:<p>\n");
-		fprintf(cgiOut, "Name: ");	
+		fprintf(cgiOut, "Name: ");
 		cgiHtmlEscape(cname);
-		fprintf(cgiOut, "Value: ");	
+		fprintf(cgiOut, "Value: ");
 		cgiHtmlEscape(cvalue);
 		fprintf(cgiOut, "<p>\n");
-		fprintf(cgiOut, "If your browser accepts cookies (many do not), this new cookie should appear in the above list the next time the form is submitted.<p>\n"); 
+		fprintf(cgiOut, "If your browser accepts cookies (many do not), this new cookie should appear in the above list the next time the form is submitted.<p>\n");
 	}
 	cgiStringArrayFree(array);
 }
-	
+
 void File()
 {
 	cgiFilePtr file;
@@ -329,7 +329,7 @@ void File()
 	if (cgiFormFileName("file", name, sizeof(name)) != cgiFormSuccess) {
 		printf("<p>No file was uploaded.<p>\n");
 		return;
-	} 
+	}
 	fprintf(cgiOut, "The filename submitted was: ");
 	cgiHtmlEscape(name);
 	fprintf(cgiOut, "<p>\n");
@@ -442,12 +442,12 @@ void CookieSet()
 	char cname[1024];
 	char cvalue[1024];
 	/* Must set cookies BEFORE calling cgiHeaderContentType */
-	cgiFormString("cname", cname, sizeof(cname));	
-	cgiFormString("cvalue", cvalue, sizeof(cvalue));	
+	cgiFormString("cname", cname, sizeof(cname));
+	cgiFormString("cvalue", cvalue, sizeof(cvalue));
 	if (strlen(cname)) {
 		/* Cookie lives for one day (or until browser chooses
 			to get rid of it, which may be immediately),
-			and applies only to this script on this site. */	
+			and applies only to this script on this site. */
 		cgiHeaderCookieSetString(cname, cvalue,
 			86400, cgiScriptName, SERVER_NAME);
 	}
@@ -455,8 +455,8 @@ void CookieSet()
 
 void LoadEnvironment()
 {
-	if (cgiReadEnvironment(SAVED_ENVIRONMENT) != 
-		cgiEnvironmentSuccess) 
+	if (cgiReadEnvironment(SAVED_ENVIRONMENT) !=
+		cgiEnvironmentSuccess)
 	{
 		cgiHeaderContentType("text/html");
 		fprintf(cgiOut, "<head>Error</head>\n");
@@ -471,8 +471,8 @@ void LoadEnvironment()
 
 void SaveEnvironment()
 {
-	if (cgiWriteEnvironment(SAVED_ENVIRONMENT) != 
-		cgiEnvironmentSuccess) 
+	if (cgiWriteEnvironment(SAVED_ENVIRONMENT) !=
+		cgiEnvironmentSuccess)
 	{
 		fprintf(cgiOut, "<p>cgiWriteEnvironment failed. Most "
 			"likely %s is not a valid path or is not "
@@ -484,7 +484,7 @@ void SaveEnvironment()
 			"scenario: "
 			"<form method=POST action=\"");
 		cgiValueEscape(cgiScriptName);
-		fprintf(cgiOut, "\">" 
+		fprintf(cgiOut, "\">"
 			"<input type=\"submit\" "
 			"value=\"Load Environment\" "
 			"name=\"loadenvironment\"></form><p>\n");
-- 
2.24.1

